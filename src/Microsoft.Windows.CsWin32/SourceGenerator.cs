// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.Windows.CsWin32;

/// <summary>
/// Generates the source code for the p/invoke methods and supporting types into some C# project.
/// </summary>
[Generator]
public class SourceGenerator : ISourceGenerator
{
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
    public static readonly DiagnosticDescriptor InternalError = new DiagnosticDescriptor(
        "PInvoke000",
        "CsWin32InternalError",
        "An internal error occurred: {0}",
        "Functionality",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoMatchingMethodOrType = new DiagnosticDescriptor(
        "PInvoke001",
        "No matching method, type or constant found",
        "Method, type or constant \"{0}\" not found.",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoMatchingMethodOrTypeWithBadCharacters = new DiagnosticDescriptor(
        "PInvoke001",
        "No matching method, type or constant found",
        "Method, type or constant \"{0}\" not found. It contains unexpected characters, possibly including invisible characters, which can happen when copying and pasting from docs.microsoft.com among other places. Try deleting the line and retyping it.",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoMatchingMethodOrTypeWithSuggestions = new DiagnosticDescriptor(
        "PInvoke001",
        "No matching method, type or constant found",
        "Method, type or constant \"{0}\" not found. Did you mean {1}?",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NoMethodsForModule = new DiagnosticDescriptor(
        "PInvoke001",
        "No module found",
        "No methods found under module \"{0}\".",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UnsafeCodeRequired = new DiagnosticDescriptor(
        "PInvoke002",
        "AllowUnsafeCode",
        "AllowUnsafeBlocks must be set to 'true' in the project file for many APIs. Compiler errors may result.",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Many generated types or P/Invoke methods require use of pointers, so the receiving compilation must allow unsafe code.");

    public static readonly DiagnosticDescriptor BannedApi = new DiagnosticDescriptor(
        "PInvoke003",
        "BannedAPI",
        "This API will not be generated. {0}",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UseEnumValueDeclaringType = new DiagnosticDescriptor(
        "PInvoke004",
        "UseEnumDeclaringType",
        "Use the name of the enum that declares this constant: {0}",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Constants that are defined within enums should be generated by requesting the name of their declaring enum instead.");

    public static readonly DiagnosticDescriptor CpuArchitectureIncompatibility = new DiagnosticDescriptor(
        "PInvoke005",
        "TargetSpecificCpuArchitecture",
        "This API is only available when targeting a specific CPU architecture. AnyCPU cannot generate this API.",
        "Functionality",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor DocParsingError = new DiagnosticDescriptor(
        "PInvoke006",
        "DocsParseError",
        "An error occurred while reading docs file: \"{0}\": {1}",
        "Configuration",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor AmbiguousMatchError = new DiagnosticDescriptor(
        "PInvoke007",
        "AmbiguousMatch",
        "The API \"{0}\" is ambiguous.",
        "Functionality",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor AmbiguousMatchErrorWithSuggestions = new DiagnosticDescriptor(
        "PInvoke007",
        "AmbiguousMatch",
        "The API \"{0}\" is ambiguous. Please specify one of: {1}",
        "Functionality",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor OptionsParsingError = new DiagnosticDescriptor(
        "PInvoke008",
        "BadOptions",
        "An error occurred while parsing \"{0}\": {1}",
        "Configuration",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

    private const string NativeMethodsTxtAdditionalFileName = "NativeMethods.txt";
    private const string NativeMethodsJsonAdditionalFileName = "NativeMethods.json";
    private static readonly char[] ZeroWhiteSpace = new char[] { '\uFEFF', '\u200B' };

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.Compilation is not CSharpCompilation compilation)
        {
            return;
        }

        GeneratorOptions options;
        AdditionalText? nativeMethodsJsonFile = context.AdditionalFiles
            .FirstOrDefault(af => string.Equals(Path.GetFileName(af.Path), NativeMethodsJsonAdditionalFileName, StringComparison.OrdinalIgnoreCase));
        if (nativeMethodsJsonFile is object)
        {
            string optionsJson = nativeMethodsJsonFile.GetText(context.CancellationToken)!.ToString();
            try
            {
                options = JsonSerializer.Deserialize<GeneratorOptions>(optionsJson, new JsonSerializerOptions
                {
                    AllowTrailingCommas = true,
                    ReadCommentHandling = JsonCommentHandling.Skip,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                });
            }
            catch (JsonException ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(OptionsParsingError, location: null, nativeMethodsJsonFile.Path, ex.Message));
                return;
            }
        }
        else
        {
            options = new GeneratorOptions();
        }

        IEnumerable<AdditionalText> nativeMethodsTxtFiles = context.AdditionalFiles
            .Where(af => string.Equals(Path.GetFileName(af.Path), NativeMethodsTxtAdditionalFileName, StringComparison.OrdinalIgnoreCase));
        if (!nativeMethodsTxtFiles.Any())
        {
            return;
        }

        var parseOptions = (CSharpParseOptions)context.ParseOptions;

        if (!compilation.Options.AllowUnsafe)
        {
            context.ReportDiagnostic(Diagnostic.Create(UnsafeCodeRequired, location: null));
        }

        Docs? docs = ParseDocs(context);
        IReadOnlyList<Generator> generators = CollectMetadataPaths(context).Select(path => new Generator(path, docs, options, compilation, parseOptions)).ToList();
        try
        {
            SuperGenerator.Combine(generators);
            foreach (AdditionalText nativeMethodsTxtFile in nativeMethodsTxtFiles)
            {
                SourceText? nativeMethodsTxt = nativeMethodsTxtFile.GetText(context.CancellationToken);
                if (nativeMethodsTxt is null)
                {
                    return;
                }

                foreach (TextLine line in nativeMethodsTxt.Lines)
                {
                    context.CancellationToken.ThrowIfCancellationRequested();
                    string name = line.ToString();
                    if (string.IsNullOrWhiteSpace(name) || name.StartsWith("//", StringComparison.InvariantCulture))
                    {
                        continue;
                    }

                    name = name.Trim().Trim(ZeroWhiteSpace);
                    var location = Location.Create(nativeMethodsTxtFile.Path, line.Span, nativeMethodsTxt.Lines.GetLinePositionSpan(line.Span));
                    try
                    {
                        if (Generator.GetBannedAPIs(options).TryGetValue(name, out string? reason))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(BannedApi, location, reason));
                            continue;
                        }

                        if (name.EndsWith(".*", StringComparison.Ordinal))
                        {
                            string? moduleName = name.Substring(0, name.Length - 2);
                            int matches = 0;
                            foreach (Generator generator in generators)
                            {
                                if (generator.TryGenerateAllExternMethods(moduleName, context.CancellationToken))
                                {
                                    matches++;
                                }
                            }

                            switch (matches)
                            {
                                case 0:
                                    context.ReportDiagnostic(Diagnostic.Create(NoMethodsForModule, location, moduleName));
                                    break;
                                case > 1:
                                    context.ReportDiagnostic(Diagnostic.Create(AmbiguousMatchError, location, moduleName));
                                    break;
                            }

                            continue;
                        }

                        List<string> matchingApis = new();
                        foreach (Generator generator in generators)
                        {
                            if (generator.TryGenerate(name, out IReadOnlyList<string> preciseApi, context.CancellationToken))
                            {
                                matchingApis.AddRange(preciseApi);
                                continue;
                            }

                            matchingApis.AddRange(preciseApi);
                            if (generator.TryGetEnumName(name, out string? declaringEnum))
                            {
                                context.ReportDiagnostic(Diagnostic.Create(UseEnumValueDeclaringType, location, declaringEnum));
                                generator.TryGenerate(declaringEnum, out preciseApi, context.CancellationToken);
                                matchingApis.AddRange(preciseApi);
                            }
                        }

                        switch (matchingApis.Count)
                        {
                            case 0:
                                ReportNoMatch(location, name);
                                break;
                            case > 1:
                                context.ReportDiagnostic(Diagnostic.Create(AmbiguousMatchErrorWithSuggestions, location, name, ConcatSuggestions(matchingApis)));
                                break;
                        }
                    }
                    catch (GenerationFailedException ex)
                    {
                        if (Generator.IsPlatformCompatibleException(ex))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(CpuArchitectureIncompatibility, location));
                        }
                        else
                        {
                            // Build up a complete error message.
                            context.ReportDiagnostic(Diagnostic.Create(InternalError, location, AssembleFullExceptionMessage(ex)));
                        }
                    }
                }
            }

            foreach (Generator generator in generators)
            {
                IOrderedEnumerable<KeyValuePair<string, CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax>>? compilationUnits = generator.GetCompilationUnits(context.CancellationToken)
                    .OrderBy(pair => pair.Key, StringComparer.OrdinalIgnoreCase)
                    .ThenBy(pair => pair.Key, StringComparer.Ordinal);
                foreach (KeyValuePair<string, CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax> unit in compilationUnits)
                {
                    context.AddSource($"{generator.InputAssemblyName}.{unit.Key}", unit.Value.GetText(Encoding.UTF8));
                }
            }

            string ConcatSuggestions(IReadOnlyList<string> suggestions)
            {
                var suggestionBuilder = new StringBuilder();
                for (int i = 0; i < suggestions.Count; i++)
                {
                    if (i > 0)
                    {
                        suggestionBuilder.Append(i < suggestions.Count - 1 ? ", " : " or ");
                    }

                    suggestionBuilder.Append('"');
                    suggestionBuilder.Append(suggestions[i]);
                    suggestionBuilder.Append('"');
                }

                return suggestionBuilder.ToString();
            }

            void ReportNoMatch(Location? location, string failedAttempt)
            {
                List<string> suggestions = new();
                foreach (Generator generator in generators)
                {
                    suggestions.AddRange(generator.GetSuggestions(failedAttempt).Take(4));
                }

                if (suggestions.Count > 0)
                {
                    context.ReportDiagnostic(Diagnostic.Create(NoMatchingMethodOrTypeWithSuggestions, location, failedAttempt, ConcatSuggestions(suggestions)));
                }
                else
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        Generator.ContainsIllegalCharactersForAPIName(failedAttempt) ? NoMatchingMethodOrTypeWithBadCharacters : NoMatchingMethodOrType,
                        location,
                        failedAttempt));
                }
            }
        }
        finally
        {
            foreach (Generator generator in generators)
            {
                generator.Dispose();
            }
        }
    }

    private static string AssembleFullExceptionMessage(Exception ex)
    {
        var sb = new StringBuilder();

        Exception? inner = ex;
        while (inner is object)
        {
            sb.Append(inner.Message);
            if (sb.Length > 0 && sb[sb.Length - 1] != '.')
            {
                sb.Append('.');
            }

            sb.Append(' ');
            inner = inner.InnerException;
        }

        sb.AppendLine();
        sb.AppendLine(ex.ToString());

        return sb.ToString();
    }

    private static IReadOnlyList<string> CollectMetadataPaths(GeneratorExecutionContext context)
    {
        if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.CsWin32InputMetadataPaths", out string? delimitedMetadataBasePaths) ||
            string.IsNullOrWhiteSpace(delimitedMetadataBasePaths))
        {
            return Array.Empty<string>();
        }

        string[] metadataBasePaths = delimitedMetadataBasePaths.Split('|');
        return metadataBasePaths;
    }

    private static Docs? ParseDocs(GeneratorExecutionContext context)
    {
        Docs? docs = null;
        if (context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.CsWin32InputDocPaths", out string? delimitedApiDocsPaths) &&
            !string.IsNullOrWhiteSpace(delimitedApiDocsPaths))
        {
            string[] apiDocsPaths = delimitedApiDocsPaths!.Split('|');
            if (apiDocsPaths.Length > 0)
            {
                List<Docs> docsList = new(apiDocsPaths.Length);
                foreach (string path in apiDocsPaths)
                {
                    try
                    {
                        docsList.Add(Docs.Get(path));
                    }
                    catch (Exception e)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DocParsingError, null, path, e.Message));
                    }
                }

                docs = Docs.Merge(docsList);
            }
        }

        return docs;
    }
}
